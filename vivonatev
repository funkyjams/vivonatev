#!/bin/env python2.7

# Define Custom Exceptions:
class CustomException(Exception):
	def __init__(self, message):
		self.message = message
	def __str__(self):
		return repr(self.message)

class NoIndex(CustomException):
	def __init__(self, message):
		self.message = message

class BelowThreshold(CustomException):
	def __init__(self, message):
		self.message = message

class WrongLog(CustomException):
	def __init__(self, message):
		self.message = message



# Define functions
def exit(string):
	print string
	parser.print_help()
	sys.exit()


def run(cmd, logfile):

	logfile.write('Running: ' + cmd + '\n')

	process = subprocess.Popen(cmd.split(), stdout=logfile, stderr=logfile)
	process.communicate()[0]
	process.wait()


def isAboveThreshold(logfile, t):
	return False
	import re
	lines=logfile.readlines()
	if t == 0:
		return true

	for line in lines:
		if re.search("aligned 0 times", line):
			num = float(line.split()[1][1:6])

			if (num > (100 - t)):
				return False
			else:
				return True

	raise WrongLog("No alignement information in log file")



def loop(args, refname, logpath):
	
	log = open(logpath, 'a+')

	if (not os.path.exists("temp.fq")):
		precommand = "cp " + args['input'] + " temp.fq"
		run(precommand, log)
	

	run("bowtie2 -p 4 -U temp.fq -x " + args['directory'] + refname[:-1] + " -S temp.sam", log)
	run("samtools view -bS -o temp.bam temp.sam", log)

	try:
		if (not args['sampling'] or isAboveThreshold(log, args['threshold'])):
			if args['filter_out']:
				run("samtools view -b -f 4 temp.bam -o unmapped-temp.bam", log)
				run("rm temp.fq", log)
				run("bam2fq unmapped-temp.bam temp.fq", log)
				run("rm unmapped-temp.bam", log)
			if args['coverage']:
				run("samtools sort temp.bam temp.sorted", log)
				run("samtools mpileup -BQ0 -d 10000 -f " + args['directory'] + refname[:-1] + " temp.sorted.bam > coverage.txt", log)
				run("mv coverage.txt " + refname[:-1] + "_CoverageVector", log)
				run("rm temp.sorted.bam", log)
		else:
			# run("rm temp.sam temp.bam", log) --> Ran when catching exception
			raise BelowThreshold("")
	except WrongLog as e:
		print e
		log.write("Error:\nNo alignemtent in log file\nEnding job")
	except BelowThreshold as e:
		print e
		log.write("Warning:\nAlignement ratio below threshold\nWrapping up")
	finally:
		run("rm temp.sam temp.bam", log)
		log.close()
	
	
	

# Main function:
def main(args):
	"""Main loop"""

	#try:
	if (not os.path.isdir(args['directory'])):
		raise ValueError("Directory does not exist")

	if (not args['name_index'] is ''):
		path = args['name_index']
	else:
		path = args['directory'] + '/name_index'

	if (not os.path.exists(path)):
		raise NoIndex("Specified argument for name-index does not exists, of directory/name_index does not exit")
	else:
		index = open(path, 'r')
			
	#except NoIndex as e:
	#	print e
	#	exit("\n")


	#else:
	# Normal Development:

	lines = index.readlines()
	for name in lines:	

		print "Filtering: " + name[:-1]
		
		if (not args['logfile'] == ''):
			logpath = args['logfile'] + "_" + name[:-1]
		else:	
			logpath = "temp-log_" + name[:-1]
	
			
		loop(args, name, logpath)
		


	lastcommand = "mv temp.fq output.fq"
	print "Running: " + lastcommand
	process = subprocess.Popen(lastcommand.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
	process.communicate()[0]
		
	
	print "Main done"
	



# Prepare Arguments: 
if __name__ == "__main__":
	
	import os
	import sys
	import argparse
	import subprocess
	import re
	# import clasases
	
	parser = argparse.ArgumentParser(description='Pipeline project',
					prog='vivonatev', usage='%(prog)s -i',
					add_help=False)

	required = parser.add_argument_group('Required Arguments')
	required.add_argument('-i', '--input', default='', help='input files')
	required.add_argument('-d', '--directory', default='', help='Directory of positive control references')

	optional = parser.add_argument_group('Optional Arguments')
	optional.add_argument('-h', '--help', action='help', help='This helpful message')
	optional.add_argument('-l', '--logfile', default='', help='store output in logfile, else prints to stdout')
	optional.add_argument('-n', '--name_index', default='', help='file containing the list of references (in \'directory\' to check')
	optional.add_argument('-t', '--threshold', type=float, default=1, help='threshold of aligned reads in order to perform filter and coverage actions (in percentage)')
	optional.add_argument('-F', '--filter-out', action='store_true', help='Filter out positive references')
	optional.add_argument('-C', '--coverage', action='store_true', help='Generate coverage vectore for each reference')
	optional.add_argument('-D', '--debug', action='store_true', help='Print command list instead of executing them')
	optional.add_argument('-S', '--sampling', action='store_true', help='If only running samples, don\'t perform filtering or coverage action')
	
	args = vars( parser.parse_args() )


	## Check input validity	
	if (args['input'] is ''):
		exit('Input must be specified')
	if (args['directory'] is ''):
		exit('Positive references directory must be specified')
	
	
	try:
		main(args)
	except NoIndex as e:
		print e
	except ValueError as e:
		print e
		print("The input directory does not exist or cannot be found")
	finally:
		print "Program done"
		
	
