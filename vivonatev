#!/bin/env python2.7

# Define Custom Exceptions:
class CustomException(Exception):
	def __init__(self, message):
		self.message = message
	def __str__(self):
		return repr(self.message)

class NoIndex(CustomException):
	def __init__(self, message):
		self.message = message

class BelowThreshold(CustomException):
	def __init__(self, message):
		self.message = message

class WrongLog(CustomException):
	def __init__(self, message):
		self.message = message



# Define functions
def exit(string):
	print string
	parser.print_help()
	sys.exit()


def run(cmd, logfile):
	logfile.write('Running: ' + cmd + '\n')

	process = subprocess.Popen(cmd.split(), stdout=logfile, stderr=logfile)
	process.communicate()[0]
	process.wait()


def isAboveThreshold(logpath, t):
	if t == 0:
		return True

	else:
		import re
		logfile = open(logpath, 'r')
	
		lines = logfile.readlines()
		for line in lines:
			if re.search("aligned 0 times", line):
				if float(line.split()[0]) == 0:
					return False
	
				num = float(line.split()[1][1:6])
	
				if (num > (100 - t)):
					return False
				else:
					return True
	
		logfile.close()

	raise WrongLog("No alignement information in log file")
	return 0


def loop(args, refname, logpath):
	try:
		log = open(logpath, 'w+')

		# ToDo: throw exception if dir/refname DNE
		if (not args['input'] is ''):
			run("bowtie2 -p " + str(args['bowtie_cores']) + " -U temp.fq -x " + args['directory'] + refname[:-1] + " -S temp.sam", log)
		else:
			run("bowtie2 -p " + str(args['bowtie_cores']) + " -1 temp_1.fq -2 temp_2.fq -x " + args['directory'] + refname[:-1] + " -S temp.sam", log)

		if args['sampling']:
			pass
		elif (not isAboveThreshold(logpath, args['threshold'])):
			raise BelowThreshold('Mapping rate is too low')
		else:
			run("samtools view -bS -o temp.bam " + "-@ " + str(args['samtools_cores']) + " temp.sam", log)

			if args['filter_out']:
				print "Filtering"
				run("samtools view -b -f 4 temp.bam -o unmapped-temp.bam -@ " + str(args['samtools_cores']), log)

				if (not args['input'] is ''):
					run("rm temp.fq", log)
					run("java -jar /opt/picard-tools-1.109/SamToFastq.jar I=unmapped-temp.bam F=temp.fq", log)
				else:
					run("rm temp_1.fq temp_2.fq", log)
					run("java -jar /opt/picard-tools-1.109/SamToFastq.jar I=unmapped-temp.bam F=temp_1.fq F2=temp_2.fq FU=/dev/null", log)
				
				run("rm unmapped-temp.bam", log)
			if args['coverage']:
				print "Generating Coverage vector"
				run("samtools sort temp.bam temp.sorted", log)
				run("samtools mpileup -BQ0 -d 10000 -f " + args['directory'] + refname[:-1] + " temp.sorted.bam > coverage.txt", log)

				
				if args['vector_index'] is '':
					vector_length = len( open('coverage.txt','r').readlines() )
				else:
					# ToDo: find vector_length in file
					pass
						
				run("vect2.py " + vectorlength + " coverage.txt " +refname[:-1] + "_coverage.vect", log)  
				#run("mv coverage.txt " + refname[:-1] + "_CoverageVector", log)
				run("rm temp.sorted.bam", log)
			run("rm temp.bam", log)


	except WrongLog as e:
		print e
		log.write("Error:\nNo alignemtent in log file\nEnding job")
	except BelowThreshold as e:
		print e
		log.write("Warning:\nAlignement ratio below threshold\nWrapping up")
	finally:
		run("rm temp.sam", log)
		log.close()
	
	
	

# Main function:
def main(args):
	"""Main loop"""

	if (not os.path.isdir(args['directory'])):
		raise ValueError("Directory does not exist")

	if (not args['name_index'] is ''):
		path = args['name_index']
	else:
		path = args['directory'] + '/name_index'

	if (not os.path.exists(path)):
		raise NoIndex("Specified argument for name-index does not exists, of directory/name_index does not exit")
	else:
		index = open(path, 'r')
			
	if (not args['input'] is ''):
		if not os.path.exists("temp.fq"):
			run("cp " + args['input'] + " temp.fq", sys.stdout)
		else:
			print "Fq tempfile already exists"
	else:
		if not os.path.exists("temp_1.fq"):
		
			run("cp " + args['mate_1'] + " temp_1.fq", sys.stdout)
			run("cp " + args['mate_2'] + " temp_2.fq", sys.stdout)
		else:
			print "Fq tempfiles already exist"	

	lines = index.readlines()
	

	for name in lines:	

		print "Mapping: " + name[:-1]
		
		if (not args['logfile'] == ''):
			logpath = args['logfile'] + "_" + name[:-1]
		else:	
			logpath = "temp-log_" + name[:-1]
	
		# try	
		loop(args, name, logpath)
		# except 

	if args['filter_out']:
		if (args['input'] is not ''):
			lastcommand = "mv temp.fq output.fq"
			run(lastcommand, sys.stdout)
		else:
			lastcommand1 = "mv temp_1.fq output_1.fq"
			lastcommand2 = "mv temp_2.fq output_2.fq"
			run(lastcommand1, sys.stdout)
			run(lastcommand2, sys.stdout)
		
	
	print "Main done"
	



# Prepare Arguments: 
if __name__ == "__main__":
	
	import os
	import sys
	import argparse
	import subprocess
	import re

	
	parser = argparse.ArgumentParser(description='Pipeline project',
					prog='vivonatev', usage='%(prog)s -i input_file -d <path/to/directory/> [optional arguments]',
					formatter_class=lambda prog: argparse.HelpFormatter(prog, max_help_position = 75, width = 150),
					add_help=False)

	required = parser.add_argument_group('Required Arguments')
	required.add_argument('-i', '--input', default='', help='input files (can be replaced by paired inputs -m1 and -m2)')
	required.add_argument('-d', '--directory', default='', help='Directory of positive control references')

	optional = parser.add_argument_group('Optional Arguments')
	optional.add_argument('-h', '--help', action='help', help='This helpful message')
	optional.add_argument('-m1', '--mate-1', default='', help='Mated input 1')
	optional.add_argument('-m2', '--mate-2', default='', help='Mated input 2')
	optional.add_argument('-l', '--logfile', default='', help='store output in logfile, else prints to stdout')
	optional.add_argument('-n', '--name_index', default='', help='file containing the list of references (in \'directory\' to check')
	optional.add_argument('-v', '--vector_index', default='', help='file containing the length of genomes')
	optional.add_argument('-bc', '--bowtie-cores', default=2, type=int, help='number of cores to use when running bowtie2 mapping')
	optional.add_argument('-sc', '--samtools-cores', default=2, type=int, help='number of cores to when running samtools')
	optional.add_argument('-t', '--threshold', type=float, default=0, help='threshold of aligned reads in order to perform filter and coverage actions (in percentage)')
	optional.add_argument('-F', '--filter-out', action='store_true', help='Filter out positive references')
	optional.add_argument('-C', '--coverage', action='store_true', help='Generate coverage vectore for each reference')
	optional.add_argument('-D', '--debug', action='store_true', help='Print command list instead of executing them')
	optional.add_argument('-S', '--sampling', action='store_true', help='If only running samples, don\'t perform filtering or coverage action')
	
	args = vars( parser.parse_args() )


	## Check input validity	
	if (args['input'] is ''):
		if (args['mate_1'] is '' or args['mate_2'] is ''):
			exit('Input must be specified')
	if (not args['mate_1'] is '' or not args['mate_2'] is ''):
		if (not args['input'] is ''):
			exit('Cannot map paired and unpaired reads at the same time')
	if (args['directory'] is ''):
		exit('Positive references directory must be specified')
	if (args['sampling'] and args['logfile'] is ''):
		exit('Sampling mode requires logfiles, otherwise it does nothing')
	
	
	try:
		main(args)
	except NoIndex as e:
		print e
	except ValueError as e:
		print e
		print("The input directory does not exist or cannot be found")
	finally:
		print "Program done"
		
	
