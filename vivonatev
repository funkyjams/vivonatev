#!/bin/env python2.7

# Define Custom Exceptions:
class CustomException(Exception):
	def __init__(self, message):
		self.message = message
	def __str__(self):
		return repr(self.message)

class NoIndex(CustomException):
	def __init__(self, message):
		self.message = message

class BelowThreshold(CustomException):
	def __init__(self, message):
		self.message = message

class WrongLog(CustomException):
	def __init__(self, message):
		self.message = message



# Define functions
def exit(string):
	print string
	parser.print_help()
	sys.exit()


def run(cmd, logfile):

	logfile.write('Running: ' + cmd + '\n')

	process = subprocess.Popen(cmd.split(), stdout=logfile, stderr=logfile)
	process.communicate()[0]
	process.wait()


def isAboveThreshold(logpath, t):
	if t == 0:
		return True

	else:
		import re
		logfile = open(logpath, 'r')
	
		lines = logfile.readlines()
		for line in lines:
			if re.search("aligned 0 times", line):
				if float(line.split()[0]) == 0:
					return False
	
				num = float(line.split()[1][1:6])
	
				if (num > (100 - t)):
					return False
				else:
					return True
	
		logfile.close()

	raise WrongLog("No alignement information in log file")
	return 0


def loop(args, refname, logpath):
	
	log = open(logpath, 'w+')

	
	run("bowtie2 -p " + str(args['bowtie_cores']) + " -U temp.fq -x " + args['directory'] + refname[:-1] + " -S temp.sam", log)

	try:
		if args['sampling']:
			pass
		elif (not isAboveThreshold(logpath, args['threshold'])):
			raise BelowThreshold('Mapping rate is too low')
		else:
			run("samtools view -bS -o temp.bam " + "-@ " + str(args['samtools_cores']) + " temp.sam", log)
			if args['filter_out']:
				print "Filtering"
				run("samtools view -b -f 4 temp.bam -o unmapped-temp.bam", log)
				run("rm temp.fq", log)
				run("java -jar /opt/picard-tools-1.109/SamToFastq.jar I=unmapped-temp.bam F=temp.fq", log)
				run("rm unmapped-temp.bam", log)
			if args['coverage']:
				print "Generating Coverage vector"
				run("samtools sort temp.bam temp.sorted", log)
				run("samtools mpileup -BQ0 -d 10000 -f " + args['directory'] + refname[:-1] + " temp.sorted.bam > coverage.txt", log)
				run("mv coverage.txt " + refname[:-1] + "_CoverageVector", log)
				run("rm temp.sorted.bam", log)
			run("rm temp.bam", log)


	except WrongLog as e:
		print e
		log.write("Error:\nNo alignemtent in log file\nEnding job")
	except BelowThreshold as e:
		print e
		log.write("Warning:\nAlignement ratio below threshold\nWrapping up")
	finally:
		run("rm temp.sam", log)
		log.close()
	
	
	

# Main function:
def main(args):
	"""Main loop"""

	if (not os.path.isdir(args['directory'])):
		raise ValueError("Directory does not exist")

	if (not args['name_index'] is ''):
		path = args['name_index']
	else:
		path = args['directory'] + '/name_index'

	if (not os.path.exists(path)):
		raise NoIndex("Specified argument for name-index does not exists, of directory/name_index does not exit")
	else:
		index = open(path, 'r')
			

	run("cp " + args['input'] + " temp.fq", sys.stdout)

	lines = index.readlines()
	

	for name in lines:	

		print "Mapping: " + name[:-1]
		
		if (not args['logfile'] == ''):
			logpath = args['logfile'] + "_" + name[:-1]
		else:	
			logpath = "temp-log_" + name[:-1]
	
		# try	
		loop(args, name, logpath)
		# except 

	if args['filter_out']:
		lastcommand = "mv temp.fq output.fq"
		run(lastcommand, sys.stdout)
		# print "Running: " + lastcommand
		process = subprocess.Popen(lastcommand.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
		process.communicate()[0]
		
	
	print "Main done"
	



# Prepare Arguments: 
if __name__ == "__main__":
	
	import os
	import sys
	import argparse
	import subprocess
	import re
	# import clasases
	
	parser = argparse.ArgumentParser(description='Pipeline project',
					prog='vivonatev', usage='%(prog)s -i',
					add_help=False)

	required = parser.add_argument_group('Required Arguments')
	required.add_argument('-i', '--input', default='', help='input files')
	required.add_argument('-d', '--directory', default='', help='Directory of positive control references')

	optional = parser.add_argument_group('Optional Arguments')
	optional.add_argument('-h', '--help', action='help', help='This helpful message')
	optional.add_argument('-l', '--logfile', default='', help='store output in logfile, else prints to stdout')
	optional.add_argument('-n', '--name_index', default='', help='file containing the list of references (in \'directory\' to check')
	optional.add_argument('-bc', '--bowtie-cores', default=2, type=int, help='number of cores to use when running bowtie2 mapping')
	optional.add_argument('-sc', '--samtools-cores', default=2, type=int, help='number of cores to when running samtools')
	optional.add_argument('-t', '--threshold', type=float, default=0, help='threshold of aligned reads in order to perform filter and coverage actions (in percentage)')
	optional.add_argument('-F', '--filter-out', action='store_true', help='Filter out positive references')
	optional.add_argument('-C', '--coverage', action='store_true', help='Generate coverage vectore for each reference')
	optional.add_argument('-D', '--debug', action='store_true', help='Print command list instead of executing them')
	optional.add_argument('-S', '--sampling', action='store_true', help='If only running samples, don\'t perform filtering or coverage action')
	
	args = vars( parser.parse_args() )


	## Check input validity	
	if (args['input'] is ''):
		exit('Input must be specified')
	if (args['directory'] is ''):
		exit('Positive references directory must be specified')
	
	
	try:
		main(args)
	except NoIndex as e:
		print e
	except ValueError as e:
		print e
		print("The input directory does not exist or cannot be found")
	finally:
		print "Program done"
		
	
